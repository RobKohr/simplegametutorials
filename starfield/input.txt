# Starfield

## <a href="starfield.love">Download starfield.love</a>

## Rules

Navigate a ship through the asteroid field for as long as you can.

Your score is based on the number of asteroids that you pass safely.

### Controls

& *A* or *Left arrow* & Move the ship left
& *D* or *Right arrow* & Move the ship right

## Overview

The ship doesn't actually move up, the asteroids move towards it.

Vectors and classes can help to simplify the process of creating games.

Images need to be offset to properly rotate them.

*AABB* collision detection is simple yet effective in most instances.

States make games much more flexible and easy to control.

To safely loop over tables of objects, you need to loop in reverse order.

Saving simple data can be handled trivially.

### Images

asteroid.png

!

ship.png

!

## Coding

### Basic setup

The first thing that we'll be doing is working on the asteroids portion of our game.

First, you need an asteroid. Give it an x and y and an image in love.load, and draw its image in love.draw. For this game, the screen has a width of 300 and a height of 600. For now, we want the asteroid to appear in the center of the screen.

`
function love.load()
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidX, asteroidY = 150, 300
end

function love.draw()
	love.graphics.draw( asteroidImage, asteroidX, asteroidY )
end
`

Now you should be able to see your image with its upper-left corner in the center of the window if you did everything correctly.

!

### Adding movement

Now let's add some movement to our asteroid. For this, we will need what are known as *movement vectors*. These vectors represent the velocity of the asteroid. Basically, a velocity vector represents the change that component of the asteroid's position over time. For instance, if you give the asteroid an x-velocity of 20 and a y-velocity of 20, it will slowly move down and to the right in a diagonal line.

!

If you need to learn more about vectors, I consider this a good tutorial for many potential uses of vectors in games: <a href="http://2dengine.com/doc/gs_vector.html">http://2dengine.com/doc/gs_vector.html</a>

`
function love.load()
	-- etc.
	asteroidVelocityX = 20
	asteroidVelocityY = 20
end

function love.update( dt )
	asteroidX = asteroidX + asteroidVelocityX * dt
	asteroidY = asteroidY + asteroidVelocityY * dt
end
`

If you change the x-velocity to be -20, the asteroid will move down and to the left.

### Adding rotation

Now let's add some rotation to the asteroid. 

`
function love.load()
	-- etc.
	asteroidRotation = 0
	asteroidRotationSpeed = 20
end

function love.update( dt )
	-- etc.
	asteroidRotation = asteroidRotation + asteroidRotationSpeed * dt
end
`

Oi! That's not what we wanted. The problem is that the image is rotating about its x- and y-values, which are in the top-left corner of the image by default. In order to fix this, we need to offset the image by a certain amount to allow us to rotate it about its center. We can do this with the **offset x and y** parameters for love.graphics.draw. If we offset it by half the image's width and half the image's height we should be able to rotate it about its center.

`
function love.load()
	-- etc.
	-- ImageObject:getDimensions() returns the width and height of the image
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()
end

function love.draw()
	love.graphics.draw( asteroidImage, asteroidX, asteroidY, asteroidRotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
end
`

### More asteroids

Let's add some more asteroids. I have given these some different values so you can see how each affects the asteroid.

`
function love.load()
	-- The image, width, and height will be the same for all asteroids, so we only need one of these
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()

	-- These will all be different for each asteroid
	asteroid1x, asteroid1y = 50, 0
	asteroid1velocityX = 20
	asteroid1velocityY = 20
	asteroid1rotation = 0
	asteroid1rotationSpeed = math.pi / 4
	
	asteroid2x, asteroid2y = 150, 0
	asteroid2velocityX = -20
	asteroid2velocityY = 20
	asteroid2rotation = 0
	asteroid2rotationSpeed = -math.pi / 4

	asteroid3x, asteroid3y = 250, 0
	asteroid3velocityX = -20
	asteroid3velocityY = 40
	asteroid3rotation = 0
	asteroid3rotationSpeed = math.pi / 8
end

function love.update( dt )
	asteroid1x = asteroid1x + asteroid1velocityX * dt
	asteroid1y = asteroid1y + asteroid1velocityY * dt
	asteroid1rotation = asteroid1rotation + asteroid1rotationSpeed * dt

	asteroid2x = asteroid2x + asteroid2velocityX * dt
	asteroid2y = asteroid2y + asteroid2velocityY * dt
	asteroid2rotation = asteroid2rotation + asteroid2rotationSpeed * dt

	asteroid3x = asteroid3x + asteroid3velocityX * dt
	asteroid3y = asteroid3y + asteroid3velocityY * dt
	asteroid3rotation = asteroid3rotation + asteroid3rotationSpeed * dt
end

function love.draw()
	love.graphics.draw( asteroidImage, asteroid1x, asteroid1y, asteroid1rotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
	love.graphics.draw( asteroidImage, asteroid2x, asteroid2y, asteroid2rotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
	love.graphics.draw( asteroidImage, asteroid3x, asteroid3y, asteroid3rotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
end
`

### Introducing Object Oriented Programming

As you can see, that's a lot of code just for three asteroids to move around and rotate. Imagine how complicated this could become with a larger game! Ten or more asteroids, plus all the other objects. Thankfully, we can use something called *Object Oriented Programming*, or *OOP* to save us from using all this complicated code. OOP uses classes for objects where there will be many that have similar properties, like our asteroids, for instance. Lua, unlike some other languages, has no built-in class structure, so it is up to us to roll our own. To do this, we can use tables and their properties in order to make something that resembles classes.

`
function love.load()
	-- The image, width, and height will be the same for all asteroids, so we only need one of these
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt
			end,
		}

		-- Implicit `self` parameter with the colon syntax
		function asteroid:draw()
			love.graphics.draw( asteroidImage, self.x, self.y, self.rotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
		end

		return asteroid
	end

	asteroid1 = createAsteroid( 50, 0, 20, 20, math.pi / 4 )
	asteroid2 = createAsteroid( 150, 0, -20, 20, -math.pi / 4 )
	asteroid3 = createAsteroid( 250, 0, -20, 40, math.pi / 8 )
end

function love.update( dt )
	asteroid1:update( dt )
	asteroid2:update( dt )
	asteroid3:update( dt )
end

function love.draw()
	asteroid1:draw()
	asteroid2:draw()
	asteroid3:draw()
end
`

I don't know about you, but that looks much cleaner to me! Now let's work on the ship.

### The ship

For now we don't need to draw the asteroids, so we can comment that out while we add the ship. Since there will only be one ship object, there is no need to make a class for it.

`
function love.load()
	-- The image, width, and height will be the same for all asteroids, so we only need one of these
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()

	| shipImage = love.graphics.newImage( 'ship.png' ) |
	| shipWidth, shipHeight = shipImage:getDimensions() |
	| shipX, shipY = ( 300 - shipWidth ) / 2, 500 |

	-- etc.
end

-- etc.

function love.draw()
	| -- | asteroid1:draw()
	| -- | asteroid2:draw()
	| -- | asteroid3:draw()

	-- We're not rotating the ship, so no need for offset
	love.graphics.draw( shipImage, shipX, shipY )
end
`

### Moving the ship

As you can imagine, the game isn't much fun if you can't move the ship. So, we need to add movement to the ship.

`
function love.load()
	-- etc.
	shipVelocityX, shipVelocityY = 0, 0
	shipMoveSpeed = 256
end

function love.update( dt )
	-- etc.
	shipX = shipX + shipVelocityX * dt
	shipY = shipY + shipVelocityY * dt
end

-- etc.

function love.keypressed( key )
	if ( key == 'left' or key == 'a' ) then
		shipVelocityX = -shipMoveSpeed
	end
	if ( key == 'right' or key == 'd' ) then
		shipVelocityX = shipMoveSpeed
	end
end
`

There are a few more subtle problem is solved: in many games, when you press left to move one direction, then right to move another, you stay still. In this case, you would more to the right, making the controls feel more responsive.

There is one slight problem, however: when you let go of a key, you don't stop moving!

`
function love.keyreleased( key )
	shipVelocityX = 0
end
`

Now you will notice another problem: if you begin moving left, then press to move right, then release the left key, you will stop moving! Obviously, this won't do. So how do we solve this? One simple solution would be to check if one of the other movement keys is pressed and to update the velocity accordingly.

`
function love.load()
	-- etc
	function updateShipVelocity()
		if ( love.keyboard.isDown( 'left' ) or love.keyboard.isDown( 'a' ) ) then
			shipVelocityX = -shipMoveSpeed
		end
		if ( love.keyboard.isDown( 'right' ) or love.keyboard.isDown( 'd' ) ) then
			shipVelocityX = shipMoveSpeed
		end
	end
end

-- etc.
function love.keypressed( key )
	shipVelocity = 0
	updateShipVelocity()
end
`

### Collisions

You should have seen more basic *AABB collision* (**axis-aligned bounding box**) earlier, in the bird tutorial. Here, we will implement a more robust AABB check in the update function for each asteroid to see if it is touching the ship.

`
function love.load()
	 -- The image, width, and height will be the same for all asteroids, so we only need one of these
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()

	shipImage = love.graphics.newImage( 'ship.png' )
	shipWidth, shipHeight = shipImage:getDimensions()
	shipX, shipY = ( 300 - shipWidth ) / 2, 500
	shipVelocityX, shipVelocityY = 0, 0
	shipMoveSpeed = 256

	function AABB( asteroid )
		-- Divide by 2 because the of the offset on the asteroids
		return ( asteroid.x + asteroidWidth / 2 >= shipX and
				 asteroid.x - asteroidWidth / 2 <= shipX + shipWidth and
				 asteroid.y + asteroidHeight / 2 >= shipY and
				 asteroid.y - asteroidHeight / 2 <= shipY + shipHeight )
	end
	
	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if AABB( self ) then
					self.rotationSpeed = -self.rotationSpeed
				end
			end,
		}

		-- Implicit `self` parameter with the colon syntax
		function asteroid:draw()
			love.graphics.draw( asteroidImage, self.x, self.y, self.rotation, 1, 1, asteroidWidth / 2, asteroidHeight / 2 )
		end

		return asteroid
	end

	asteroid1 = createAsteroid( 50, 0, | 0, 100, | math.pi / 4 )
	asteroid2 = createAsteroid( 150, 0, | 0, 100, | -math.pi / 4 )
	asteroid3 = createAsteroid( 250, 0, | 0, 100, | math.pi / 8 )

	-- etc.
end

function love.draw()
	| asteroid1:update( dt ) |
	| asteroid2:update( dt ) |
	| asteroid3:update( dt ) |
	-- etc.
end
`

So now when an asteroid hits the ship, it should start spinning in the opposite direction (until the next frame, where, assuming it's still hitting the ship, its rotation will stop reverse again, this time back to the original direction). This will make it *look* like it has stopped spinning. 

As you can see, the velocities of the asteroids have been changed to make it easier to check if the collision detection is right. You should also note that only one of the asteroids stops spinning.

### States

Now that we have collision, we have to make a lose screen. This of course would dsiplay our score, which we have not implemented yet, plus an option to try again or quit.

`
function love.load()
	state = 'playing'

	-- etc.
end

function love.update( dt )
	if state == 'playing' then
		asteroid1:update( dt )
		asteroid2:update( dt )
		asteroid3:update( dt )

		shipX = shipX + shipVelocityX * dt
		shipY = shipY + shipVelocityY * dt
	end
end

function love.draw()
	if state == 'playing' then
		asteroid1:draw()
		asteroid2:draw()
		asteroid3:draw()

		-- We're not rotating the ship, so no need for offset
		love.graphics.draw( shipImage, shipX, shipY )
	end
end

function love.keypressed( key )
	if state == 'playing' then
		if ( key == 'left' or key == 'a' ) then
			shipVelocityX = -shipMoveSpeed
		end
		if ( key == 'right' or key == 'd' ) then
			shipVelocityX = shipMoveSpeed
		end
	end
end

function love.keyreleased( key )
	if state == 'playing' then
		shipVelocityX = 0
		updateShipVelocity()
	end
end
`

### A better way

Now, you could do that, but it's a little cumbersome, don't you think? What if you wanted another state? You don't want to change all those if-statements, do you? That's tedious and repetitive. You want to be making a game, not drudging through that. That's where tables come in. It greatly simplifies the process of states and makes the whole thing more enjoyable.

Notice, also, that the order of the drawing was flipped. This is just so that the ship is drawn beneath the asteroids.

`
function love.load()
	states = {
		playing = {
			update = function( dt )
				asteroid1:update( dt )
				asteroid2:update( dt )
				asteroid3:update( dt )

				shipX = shipX + shipVelocityX * dt
				shipY = shipY + shipVelocityY * dt
			end,
			draw = function()
				| -- We're not rotating the ship, so no need for offset |
				| love.graphics.draw( shipImage, shipX, shipY ) |

				asteroid1:draw()
				asteroid2:draw()
				asteroid3:draw()
			end,
			keypressed = function( key )
				if ( key == 'left' or key == 'a' ) then
					shipVelocityX = -shipMoveSpeed
				end
				if ( key == 'right' or key == 'd' ) then
					shipVelocityX = shipMoveSpeed
				end
			end,
			keyreleased = function( key )
				shipVelocityX = 0
				updateShipVelocity()
			end,
		},
	}

	state = 'playing'
	-- etc.
end

function love.update( dt )
	states[state].update( dt )
end

function love.draw()
	states[state].draw()
end

function love.keypressed( key )
	states[state].keypressed( key )
end

function love.keyreleased( key )
	states[state].keyreleased( key )
end
`

# Changing the state

Now to actually add a lose state.

`
function love.load()
	states = {
		-- etc.
		lose = {
			update = function( dt ) end,
			draw = function() end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
		}
	}

	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if AABB( self ) then
					| state = 'lose' |
				end
			end,
		}
		-- etc.
	end

	-- etc.
end
`

Now, whenever the ship hits an asteroid, the screen goes completely black, which makes sense, as we have not defined the fail state yet.

### Defining the fail state

What do we want in our lose state? A replay button, quit button, and a score display at the least. 

Let's go ahead and get straight to the buttons. Because we will be using mutliple buttons and want to have the potential to add more in the future, we'll make a button class.

`
function love.load()
	-- etc.
	states = {
		-- etc.
		lose = {
			update = function( dt ) end,
			draw = function()
				| replay:draw() |
			end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
		}
	}

	state = | 'lose' |

	-- etc.
	function createButton( text, x, y, width, height )
		local button = {
			text = text,
			x = x,
			y = y,
			width = width,
			height = height,
			draw = function( self )
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.rectangle( 'fill', self.x, self.y, self.width, self.height )
				love.graphics.setColor( 0, 0, 0 )
				love.graphics.printf( self.text, self.x + 2, self.y + 2, self.width - 4, 'center' )
			end,
		}

		return button
	end

	replay = createButton( 'Replay?', 2, 2, 50, 50 )

	-- etc.
end
`

That looks alright, though it could definitely be better. For instance, don't we want to center the button vertically? I think so.

`
function love.load()
	font = love.graphics.getFont()

	-- etc.

	function createButton( text, x, y, width, height )
		| -- Vertical centering |
		| local _, lines = font:getWrap( text, width - 4 ) |
		| local numLines = #lines |
		| local fontHeight = font:getHeight( 'A' ) |
		| local spaceBetweenLines = 2 |
		| local textHeight = numLines * ( fontHeight + spaceBetweenLines ) - spaceBetweenLines |
		| local textY = y + ( height - textHeight ) / 2 |

		local button = {
			text = text,
			x = x,
			y = y,
			width = width,
			height = height,
			draw = function( self )
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.rectangle( 'fill', self.x, self.y, self.width, self.height )

				love.graphics.setColor( 0, 0, 0 )
				| love.graphics.printf( text, self.x + 2, textY, self.width - 4, 'center' ) |
			end,
		}

		return button
	end

	-- etc.
end
`

I think that looks a little bit better. Note that we implemented our own vertical scaling. You can play around with the amount of space between lines if you want to get it more accurate.

### Adding another button

`
function love.load()
	-- etc.
	states = {
		-- etc.
		lose = {
			update = function( dt ) end,
			draw = function()
				replay:draw()
				| quit:draw() |
			end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
		}
	}

	-- etc.

	replay = createButton( 'Replay?', 2, 2, 50, 50 )
	| quit = createButton( 'Quit?', 52, 52, 50, 50 ) |

	-- etc.
end
`

I hope you're beginning to see the advantage to OOP at this point.

### More robust collision

The buttons look great, but that's it right now. Not much use yet, are they? To be useful, we need to be able to click them. But how do we test for mouse clicks? The function looks the same as the AABB function from earlier, but the width is 0. As such, we need to redefine our AABB function from earlier.

`
function love.load()
	-- etc.

	state = | 'playing' |

	-- etc.
	
	| function AABB( object1x, object1y, object1w, object1h, object2x, object2y, object2w, object2h ) |
		| return ( object1x + object1w >= object2x and |
			     | object1x <= object2x + object2w and |
			     | object1y + object1h >= object2y and |
			     | object1y <= object2y + object2h ) |
	| end |

	| function asteroidAABB( asteroid ) |
		| return AABB( asteroid.x - asteroidWidth / 2, asteroid.y - asteroidHeight / 2, asteroidWidth, asteroidHeight, shipX, shipY, shipWidth, shipHeight ) |
	| end |

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if | asteroidAABB( self ) | then
					state = 'lose'
				end
			end,
		}
		
		-- etc.
	end

	-- etc.
end
`

As you can see, the collision still works just like it used to, now it's just been expanded some. Now we can move on to clicking.

### Adding clicking

The first thing we need to do is define a callback for each state for when the mouse is released. Then, we can make a simple *mouseAABB* function just like we did for the asteroids. We also, of course, need to set the state back to 'lose'.

After that, we need some way to check if the mouse is clicking a button. To do this, we have to check through each button, so we will put the active buttons in a table. We then loop through that table to check if any buttons have been clicked.

`
function love.load()
	font = love.graphics.getFont()

	states = {
		playing = {
			-- etc.
			| mousereleased = function( x, y, button ) end, |
		},
		lose = {
			update = function( dt )
			end,
			draw = function()
				for i = 1, #activeButtons do
					activeButtons[i]:draw()
				end
			end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
			| mousereleased = function( x, y, button ) |
				| if button == 1 then |
					| local clickedButton = checkButtons( x, y ) |
					| if clickedButton then |
						| print( activeButtons[i].text ) |
					| end |
				| end |
			| end, |
		}
	}

	| state = 'lose' |

	-- etc.

	| -- "object" is any table with values for "x", "y", "width", and "height" |
	| function mouseAABB( mouseX, mouseY, object ) |
		| -- screenButton to distinguish from mouse button |
		| return AABB( object.x, object.y, object.width, object.height, mouseX, mouseY, 0, 0 ) |
	| end |

	-- etc.

	replay = createButton( 'Replay?', 2, 2, 50, 50 )
	quit = createButton( 'Quit?', 52, 52, 50, 50 )

	activeButtons = { replay, quit }

	function checkButtons( mouseX, mouseY )
		for i = 1, #activeButtons do
			local result = mouseAABB( mouseX, mouseY, activeButtons[i] )
			if result then return i end
		end
	end

	-- etc.
end

-- etc.

function love.mousereleased( x, y, button )
	states[state].mousereleased( x, y, button )
end
`

### Button click callbacks

Now that all that has been added, we need to define callbacks for what to do when a button is clicked.

`
function love.load()
	-- etc.

	states = {
		-- etc.
		lose = {
			update = function( dt ) end,
			draw = function()
				replay:draw()
				quit:draw()
			end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
			mousereleased = function( x, y, button )
				if button == 1 then
					local clickedButton = checkButtons( x, y )
					if clickedButton then
						| activeButtons[clickedButton].callback() |
					end
				end
			end,
		}
	}

	-- etc.

	function createButton( text, x, y, width, height, | callback | )
		-- Vertical centering
		local _, lines = font:getWrap( text, width - 4 )
		local numLines = #lines
		local fontHeight = font:getHeight( 'A' )
		local textHeight = numLines * ( fontHeight + 2 ) - 2
		local textY = y + ( height - textHeight ) / 2

		local button = {
			text = text,
			x = x,
			y = y,
			width = width,
			height = height,
			| callback = callback, |
			draw = function( self )
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.rectangle( 'fill', self.x, self.y, self.width, self.height )

				love.graphics.setColor( 0, 0, 0 )
				love.graphics.printf( text, self.x + 2, textY, self.width - 4, 'center' )
			end,
		}

		return button
	end

	-- etc.

	replay = createButton( 'Replay?', 2, 2, 50, 50, | love.load | )
	quit = createButton( 'Quit?', 52, 52, 50, 50, | love.event.quit | )

	-- etc.
end
`

### Hover effects

Wouldn't it look fancy to have the button change colors whenever the mouse hovers over the button? To do this, we need to change button class' draw method and the button class to include its own color property. Then, add an update function that checks to see if the mouse is over the button. If it is, change the color, otherwise, set its color to the default.

`
function love.load()
	-- etc.

	states = {
		-- etc.

		lose = {
			update = function( dt )
				| replay:update( dt ) |
				| quit:update( dt ) |
			end,

			-- etc.
		}
	}

	-- etc.

	function createButton( text, x, y, width, height, callback )
		-- etc.

		local button = {
			text = text,
			x = x,
			y = y,
			width = width,
			height = height,
			callback = callback,
			| color = { 255, 255, 255 }, |
			update = function( self, dt )
				| local mouseX, mouseY = love.mouse.getPosition() |
				| if mouseAABB( mouseX, mouseY, self ) then |
					| self.color = { 125, 125, 125 } |
				| else |
					| self.color = { 255, 255, 255 } |
				| end |
			end,
			draw = function( self )
				| love.graphics.setColor( self.color ) |
				love.graphics.rectangle( 'fill', self.x, self.y, self.width, self.height )

				love.graphics.setColor( 0, 0, 0 )
				love.graphics.printf( text, self.x + 2, textY, self.width - 4, 'center' )
			end,
		}

		-- etc.
	end
end
`

### Scoring

We now have the basic foundation for our game now. Now we can focus mostly on polishing. For now, calculating the score will be pertty simple: every time you successfully avoid an asteroid, you'll get 50 points added to your score. Successfully avoiding an asteroid just means that it's made it to the bottom of the screen without touching you. Of course we need to display the score during the play state too.

`
function love.load()
	font = love.graphics.getFont()
	| screenWidth, screenHeight = love.graphics.getDimensions() |

	states = {
		playing = {
			update = function( dt )
				asteroid1:update( dt )
				asteroid2:update( dt )
				asteroid3:update( dt )

				shipX = shipX + shipVelocityX * dt
				shipY = shipY + shipVelocityY * dt
			end,
			draw = function()
				| love.graphics.setColor( 255, 255, 255 ) |
				| love.graphics.print( 'Score: ' .. score, 2, 2 ) |

				-- We're not rotating the ship, so no need for offset
				love.graphics.draw( shipImage, shipX, shipY )

				asteroid1:draw()
				asteroid2:draw()
				asteroid3:draw()
			end,

			-- etc.
		}
	}

	-- etc.

	| score = 0 |
	| state = 'play' |

	-- etc.
	
	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				| if self.y - asteroidWidth / 2 > screenHeight then |
					| score = score + 50 |
				| end |

				if asteroidAABB( self ) then
					state = 'lose'
				end
			end,
		}
		
		-- etc.
	end
end
`

### Better collission

By now you should be noticing that the collission is a bit wonky. When you get moved to the lose state, it doesn't really look like you've actually hit the asteroid at that point. We could change our spaceship to make it look more square, but we're not artists (as evidenced by our lovely graphics), we're programmers. And with a bit of math, we can make the collisions a lot more accurate.

There are a few common solutions to solving this: you could make the ship built out of several smaller boxes, that way it's more accurate. You could also do a simpler calculation and make the hitboxes circles. To see if circles intersect, you just need to do a simple comparison. Of course, our ship isn't circular, but this will look a lot better. Of course, if you wanted, you could also make the ship have many smaller circular hitboxes around the outside.

To check if two circles intersect, you get the distance between the centers of the two circles. If the distance between the circles is less than the two radii combined, the circles are intersecting.

You can read more about shape intersections and various optimizations here: <a href="http://2dengine.com/doc/gs_intersection.html">http://2dengine.com/doc/gs_intersection.html</a>

`
function love.load()
	-- etc.
	function AABB( object1x, object1y, object1w, object1h, object2x, object2y, object2w, object2h )
		return ( object1x + object1w >= object2x and
			     object1x <= object2x + object2w and
			     object1y + object1h >= object2y and
			     object1y <= object2y + object2h )
	end
	
	| function circleCircle( object1x, object1y, object1r, object2x, object2y, object2r ) |
		| return math.sqrt( ( object1x - object2x ) ^ 2 + ( object1y - object2y ) ^ 2 ) <= object1r + object2r |
	| end |

	function asteroidCollision( asteroid )
		-- Since the asteroid is a square its radius is half the width (or height)
		-- This is also true of the ship, although its image is not offset
		return circleCircle( asteroid.x, asteroid.y, asteroidWidth / 2, shipX + shipWidth / 2, shipY + shipHeight / 2, shipWidth * 1 / 3 )
	end

	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - asteroidWidth / 2 > screenHeight then
					score = score + 50
				end

				if | asteroidCollision( self ) | then
					state = 'lose'
				end
			end,
		}

		-- etc.
	end
end
`

This is already much better, but it can be made better by combining several small circles we can get a very good approximation when considering the size of the asteroids. As long as the gaps between the circles are smaller than the smallest an asteroid will get, this approximation will be fine. These number aren't exact, but are good enough.

`
function love.load()
	-- etc.

	states = {
		playing = {
			-- etc.

			draw = function()
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.print( 'Score: ' .. score, 2, 2 )

				-- We're not rotating the ship, so no need for offset
				love.graphics.draw( shipImage, shipX, shipY )

				drawAsteroids()

				| if DEBUG then |
					| love.graphics.setColor( 255, 0, 0 ) |
					| love.graphics.circle( 'line', shipX + shipWidth - shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 ) |
					| love.graphics.circle( 'line', shipX + shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 ) |
					| love.graphics.circle( 'line', shipX + shipWidth / 2, shipY + shipHeight / 2.5, shipWidth / 5 ) |
					| for i = 1, #asteroids do |
						| love.graphics.circle( 'line', asteroids[i].x, asteroids[i].y, asteroidWidth / 2 ) |
					| end |
				| end |
			end,
			keypressed = function( key )
				if ( key == 'left' or key == 'a' ) then
					shipVelocityX = -shipMoveSpeed
				end
				if ( key == 'right' or key == 'd' ) then
					shipVelocityX = shipMoveSpeed
				end
				| if key == '`' then DEBUG = not DEBUG end |
			end,

			-- etc.
		}
	}

	-- etc.

	function asteroidCollision( asteroid )
		-- Since the asteroid is a square its radius is half the width (or height)
		-- This is also true of the ship, although its image is not offset
		-- Offset the collision circle towards the front of the ship, also making it smaller.
		return circleCircle( asteroid.x, asteroid.y, asteroidWidth / 2, shipX + shipWidth / 2, shipY + shipHeight / 2.5, shipWidth / 5 )
			or circleCircle( asteroid.x, asteroid.y, asteroidWidth / 2, shipX + shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 )
			or circleCircle( asteroid.x, asteroid.y, asteroidWidth / 2, shipX + shipWidth / 3 + shipWidth / 2, shipY + shipHeight / 1.4, shipWidth / 6.5 )
	end

	-- etc.
end
`

### Dynamic asteroids

Now that you can actually avoid the asteroids you'll have noticed something: because of the way scoring works, you get infinitely many point when an asteroid passes and no more appear after it passes.

In order to make the game fun, we need to have a good way to control asteroids. It's no fun just having three asteroids on the screen at a time. But how do we do that?

Sure, we could make a variable, *asteroid1*, *asteroid2*, etc. for the most asteroids we could possible have at a time. But that's a lot of work. Instead, if we make a table hold all the asteroids, we don't need to worry about the number of asteroids on screen.

`
function love.load()
	font = love.graphics.getFont()
	screenWidth, screenHeight = love.graphics.getDimensions()

	states = {
		playing = {
			update = function( dt )
				| updateAsteroids( dt ) |

				shipX = shipX + shipVelocityX * dt
				shipY = shipY + shipVelocityY * dt
			end,
			draw = function()
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.print( 'Score: ' .. score, 2, 2 )

				-- We're not rotating the ship, so no need for offset
				love.graphics.draw( shipImage, shipX, shipY )

				| drawAsteroids() |
			end,

			-- etc.
		},
		-- etc.
	}

	-- etc.

	| -- asteroid1 = createAsteroid( 50, 0, 0, 100, math.pi / 4 ) |
	| asteroids = { |
		| createAsteroid( 50, 0, 0, 100, math.pi / 4 ), |
        | createAsteroid( 150, 0, 0, 100, -math.pi / 4 ), |
        | createAsteroid( 250, 0, 0, 100, math.pi / 8 ), |
	| } |

	| function updateAsteroids( dt ) |
		| for i = 1, #asteroids do |
			| asteroids[i]:update( dt ) |
		| end |
	| end |
 
	| function drawAsteroids() |
		| for i = 1,  #asteroids do |
			| asteroids[i]:draw() |
		| end |
	| end |

	-- etc.
end
`

### Randomizing asteroids

Asteroids just moving straight down the screen aren't really that fun or challenging. We want dynamic motion. To randomize the vector of the asteroid, remember back to how vectors work. They take an angle from 0 to 2 * pi starting from the positive x-axis. 

Note that we are changing how we're representing the vector, but it's still the same thing. This is just so that the random values are easier to calculate.

We only want angles that move downwards, however. Angles that produce "downward" motions are from pi to 2 * pi. But, some angles, such as pi, still result in almost no downward motion. In order to make asteroids always move down, we need the angle to be between pi / 3 to 2 / 3 * pi. Look up an image of the unit circle to get a better idea of what we're doing here, remembering that y **increases** as we go down. 

Also remember that love.math.random returns integers unless we supply it with no arguments. In order to get a number between pi / 3 and 2 / 3 * pi (neither of which are integers), we need to make a random number between 0 and 1, multiply that number by the difference between the max and the min, then add the minimum to it.

For the rotation, the value can be between -pi / 4 and pi / 4, which are just two arbitrary values.

`
function love.load()
	-- etc.

	function randomAsteroid()
		local vectorMagnitude = love.math.random( 100, 200 )
		local vectorAngle = ( 2 / 3 * math.pi - math.pi / 3 ) * love.math.random() + math.pi / 3
		local vectorX = vectorMagnitude * math.cos( vectorAngle )
		local vectorY = vectorMagnitude * math.sin( vectorAngle )

		return createAsteroid( love.math.random( 0, screenWidth ), -asteroidHeight, vectorX, vectorY, love.math.random( -math.pi / 4, math.pi / 4 ) )
	end

	asteroids = {}
	for i = 1, 3 do
		table.insert( asteroids, randomAsteroid() )
	end

	-- etc.
end
`

### Asteroids of different sizes

To make things seem more realistic, let's make the asteroids different sizes. Now, each asteroid will need its own radius and scale parameters. Whenever you scale up an image you need to remember to set the filter in order to prevent anti-aliasing.

`
function love.load()
	| love.graphics.setDefaultFilter( 'nearest', 'nearest' ) |
	-- etc.

	states = {
		playing = {
			-- etc.
			draw = function()
				-- etc.
				if DEBUG then
					-- etc.
					for i = 1, #asteroids do
						love.graphics.circle( 'line', asteroids[i].x, asteroids[i].y, | asteroids[i].radius | )
					end
				end
			end,
		}
	}

	-- etc.

	function asteroidCollision( asteroid )
		-- Since the asteroid is a square its radius is half the width (or height)
		-- This is also true of the ship, although its image is not offset
		return circleCircle( asteroid.x, asteroid.y, | asteroid.radius |, shipX + shipWidth / 2, shipY + shipHeight / 2.5, shipWidth / 5 )
			or circleCircle( asteroid.x, asteroid.y, | asteroid.radius |, shipX + shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 )
			or circleCircle( asteroid.x, asteroid.y, | asteroid.radius |, shipX + shipWidth / 3 + shipWidth / 2, shipY + shipHeight / 1.4, shipWidth / 6.5 )
	end

	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed, | radius | )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			| -- "or" allows a defualt value if `radius` isn't defined |
			| radius = radius or asteroidWidth / 2, |
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - | self.radius | > screenHeight then
					score = score + 50
				end
				if self.velocityX < 0 and self.x + | self.radius | < 0 then
					self.x = self.x + screenWidth + | self.radius * 2 |
				elseif self.velocityX > 0 and self.x - | self.radius | > screenWidth then
					self.x = self.x - screenWidth - | self.radius * 2 |
				end

				if asteroidCollision( self ) then
					state = 'lose'
				end
			end,
		}
		| -- Defined outside of the table so we can reference the radius |
		| asteroid.scale = asteroid.radius / ( asteroidWidth / 2 ) |


		-- Implicit `self` parameter with the colon syntax
		function asteroid:draw()
			love.graphics.draw( asteroidImage, self.x, self.y, self.rotation, | self.scale, self.scale |, asteroidWidth / 2, asteroidWidth / 2 )
		end

		return asteroid
	end

	function randomAsteroid()
		local vectorMagnitude = love.math.random( 100, 200 )
		local vectorAngle = ( 2 / 3 * math.pi - math.pi / 3 ) * love.math.random() + math.pi / 3
		local vectorX = vectorMagnitude * math.cos( vectorAngle )
		local vectorY = vectorMagnitude * math.sin( vectorAngle )

		| local radius = love.math.random( asteroidWidth / 3, 2 / 3 * asteroidWidth2 ) |

		return createAsteroid( love.math.random( 0, screenWidth ), -asteroidHeight, vectorX, vectorY, love.math.random( -math.pi / 4, math.pi / 4 ), | radius | )
	end
end
`

### Wrapping the asteroids

Now, although the asteroids are randomized, almost none of them actually make it to us. To keep things more interesting, we'll make it so that if an asteroid leaves the screen on the left or right side, we'll move it across the screen to make it continue moving. To make the transition seamless, it will start a little off-screen and move into view.

At first glance this seems okay, right? But think a little more: when the asteroid is moved to ther other side of the screen, it's still "outside" of the screen, just on the other side of the screen. To prevent this, we need to consider the object's x-velocity.

`
function love.load()
	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed )
		local asteroid = {
			x = x,
			y = y,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - self.radius > screenHeight then
					score = score + 50
				end
				| if self.velocityX < 0 and self.x + asteroidWidth / 2 < 0 then |
					| self.x = self.x + screenWidth + asteroidWidth |
				| elseif self.velocityX > ) and self.x - asteroidWidth / 2 > screenWidth then |
					| self.x = self.x - screenWidth - asteroidWidth |
				| end |

				if asteroidCollision( self ) then
					state = 'lose'
				end
			end,
		}

		-- etc.
	end

	-- etc.
end
`

### Making more asteroids

By now I'm sure you've noticed that once an asteroid moves off the screen, you score increases by 50 points forever, which is not supposed to happen. Instead, it should create more asteroids to take its place, then "destroy" itself. And we'll go ahead and add in a few more to start with.

For asteroids to destroy themselves, we need to do a few things. First, we need to make a table which contains the index of the asteroids to be removed. Later on, we need to remove all the asteroids specified in that table. To keep track of the asteroids, each one will be assigned a unique identifier that will serve as a way to locate which one to remove. We also need to create a new asteroid, since this one will be removed.

`
function love.load()
	-- etc.

	states = {
		playing = {
			update = function( dt )
				updateAsteroids( dt )

				shipX = shipX + shipVelocityX * dt
				shipY = shipY + shipVelocityY * dt

				| destroyAsteroids() |
			end,
			-- etc.
		}
		-- etc.
	}
	
	-- etc.

	| toDestroy = {} |
	| ID = 0 |

	| function destroyAsteroids() |
		| for i = 1, #toDestroy do |
			| for j = 1, #asteroids do |
				| if toDestroy[i] == asteroids[j].id then |
					| table.remove( asteroids, j ) |
					| break |
				| end |
			| end |
		| end |
	| end |

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed, radius )
		| ID = ID + 1 |
		local asteroid = {
			x = x,
			y = y,
			| id = ID, |
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			-- "or" allows a defualt value if `radius` isn't defined
			radius = radius or asteroidWidth / 2,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - self.radius > screenHeight then
					score = score + 50
					| table.insert( toDestroy, self.id ) |
					| table.insert( asteroids, randomAsteroid() ) |
				end
				-- etc.
			end,
		}
		-- etc.
	end

	-- etc.


	asteroids = {}
	for i = 1, | 6 | do
		table.insert( asteroids, randomAsteroid() )
	end

	-- etc.
end
`

This isn't very optimized and for a bigger game we would want to have a better way to remove items that doesn't require potentially looping through the whole table, but it works for our purposes.

### Bounding the player

The player can move outside of the screen. This is a problem that is easily to fix, though. Instead of automatically moving the ship, we first check to make sure the move is "legal." If the move is legal, we move them, otherwise, we prevent the illegal move from being made. To keep things clean, I've moved the ship updating to its own function.

`
function love.load()
	-- etc.

	states = {
		playing = {
			update = function( dt )
				updateAsteroids( dt )
				| updateShip( dt ) |
				destroyAsteroids()
			end,
			-- etc.
		}
		-- etc.
	}

	-- etc.

	function updateShip( dt )
		local futureX = shipX + shipVelocityX * dt
		local futureY = shipY + shipVelocityY * dt
		
		if futureX < 0 then
			futureX = 0
		elseif futureX + shipWidth > screenWidth then
			futureX = screenWidth - shipWidth
		end

		shipX = futureX
		shipY = futureY
	end

	-- etc.
end
`

### Increasing the difficulty

There are various ways to increase the difficulty. One way is to increase the complexity with time. That is, to make the size of the asteroids increase with time, increase the spawning rate with time, or a combination of both. Or you could increase the difficulty for every certain number of asteroids that pass, which in turn would increase the size and/or spawn rate. I will opt for this method, although either method is relatively easy to implement.

For every 5 asteroids that pass, the difficulty will increase. Difficulty will increase the speed and size over asteroids, as well as the rate at which they spawn, by multiplying by a small, but increasing factor.

`
function love.load()
	-- etc.

	score = 0
	| difficulty = 1 |
	| asteroidsPassed = 0 |
	state = 'playing'

	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed, radius )
		ID = ID + 1
		local asteroid = {
			x = x,
			y = y,
			id = ID,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			-- "or" allows a defualt value if `radius` isn't defined
			radius = radius or asteroidWidth / 2,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - self.radius > screenHeight then
					score = score + 50
					table.insert( toDestroy, self.id )
					table.insert( asteroids, randomAsteroid() )
					| asteroidsPassed = asteroidsPassed + 1 |
					| if asteroidsPassed % 5 == 0 then |
						| difficulty = difficulty + .1 |
					| end |
				end
				-- etc.
			end
			-- etc.
		}
		-- etc.
	end

	-- etc.

	function randomAsteroid()
		local vectorMagnitude = love.math.random( 100, 200 ) * | difficulty |
		local vectorAngle = ( 2 / 3 * math.pi - math.pi / 3 ) * love.math.random() + math.pi / 3
		local vectorX = vectorMagnitude * math.cos( vectorAngle )
		local vectorY = vectorMagnitude * math.sin( vectorAngle )

		local radius = love.math.random( asteroidWidth / 3, 2 / 3 * asteroidWidth ) * | difficulty |

		return createAsteroid( love.math.random( 0, screenWidth ), -asteroidHeight, vectorX, vectorY, love.math.random( -math.pi / 4, math.pi / 4 ), radius )
	end
end
`

You should be able to notice how it slowly gets more and more difficult until you finally are forced to lose.

### Saving your high score

Having a score is pointless if you don't have a verifiable way to show that you actually *are* better than your friends. So, you need to be able to save. This can be accomplished trivially with love.filesystem for our purposes. For more complicated games where you are serializing a table, you would need something called a **serialization library**. We can also go ahead and display the high score while we're at it.

`
function love.load()
	love.graphics.setDefaultFilter( 'nearest', 'nearest' )
	font = love.graphics.getFont()
	screenWidth, screenHeight = love.graphics.getDimensions()

	| highScore = 0 |
	| if love.filesystem.exists( 'file.lua' ) then |
		| highScore = love.filesystem.load( 'file.lua' )() |
	| end |

	states = {
		-- etc.
		lose = {
			update = function( dt )
				replay:update( dt )
				quit:update( dt )
			end,
			draw = function()
				replay:draw()
				quit:draw()

				love.graphics.setColor( 255, 255, 255 )
				love.graphics.printf( 'High score: ' .. highScore, 0, screenHeight / 2, screenWidth, 'center' )
			end,
			-- etc.
		}
	}

	-- etc.

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed, radius )
		ID = ID + 1
		local asteroid = {
			-- etc.
			update = function( self, dt )
				if asteroidCollision( self ) then
					state = 'lose'
					| if score > highScore then |
						| highScore = score |
						| love.filesystem.write( 'file.lua', 'return ' .. score ) |
					| end |
				end
			end,
		}
		-- etc.
	end
end
`

## Final Code:
`
function love.load()
	love.graphics.setDefaultFilter( 'nearest', 'nearest' )
	font = love.graphics.getFont()
	screenWidth, screenHeight = love.graphics.getDimensions()

	highScore = 0
	if love.filesystem.exists( 'file.lua' ) then
		highScore = love.filesystem.load( 'file.lua' )()
	end

	states = {
		playing = {
			update = function( dt )
				updateAsteroids( dt )
				updateShip( dt )
				destroyAsteroids()
			end,
			draw = function()
				love.graphics.setColor( 255, 255, 255 )
				love.graphics.print( 'Score: ' .. score, 2, 2 )

				-- We're not rotating the ship, so no need for offset
				love.graphics.draw( shipImage, shipX, shipY )

				drawAsteroids()

				-- Collision debug if you want to visualize it.
				if DEBUG then
					love.graphics.setColor( 255, 0, 0 )
					love.graphics.circle( 'line', shipX + shipWidth - shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 )
					love.graphics.circle( 'line', shipX + shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 )
					love.graphics.circle( 'line', shipX + shipWidth / 2, shipY + shipHeight / 2.5, shipWidth / 5 )
					for i = 1, #asteroids do
						love.graphics.circle( 'line', asteroids[i].x, asteroids[i].y, asteroids[i].radius )
					end
				end
			end,
			keypressed = function( key )
				if ( key == 'left' or key == 'a' ) then
					shipVelocityX = -shipMoveSpeed
				end
				if ( key == 'right' or key == 'd' ) then
					shipVelocityX = shipMoveSpeed
				end
				if key == '`' then DEBUG = not DEBUG end
			end,
			keyreleased = function( key )
				shipVelocityX = 0
				updateShipVelocity()
			end,
			mousereleased = function( x, y, button ) end
		},
		lose = {
			update = function( dt )
				replay:update( dt )
				quit:update( dt )
			end,
			draw = function()
				replay:draw()
				quit:draw()

				love.graphics.setColor( 255, 255, 255 )
				love.graphics.printf( 'High score: ' .. highScore, 0, screenHeight / 2, screenWidth, 'center' )
			end,
			keypressed = function( key ) end,
			keyreleased = function( key ) end,
			mousereleased = function( x, y, button )
				if button == 1 then
					local clickedButton = checkButtons( x, y )
					if clickedButton then
						activeButtons[clickedButton].callback()
					end
				end
			end,
		}
	}

	score = 0
	difficulty = 1
	asteroidsPassed = 0
	state = 'playing'

	-- The image, width, and height will be the same for all asteroids, so we only need one of these
	asteroidImage = love.graphics.newImage( 'asteroid.png' )
	asteroidWidth, asteroidHeight = asteroidImage:getDimensions()

	shipImage = love.graphics.newImage( 'ship.png' )
	shipWidth, shipHeight = shipImage:getDimensions()
	shipX, shipY = ( 300 - shipWidth ) / 2, 500
	shipVelocityX, shipVelocityY = 0, 0
	shipMoveSpeed = 256

	function AABB( object1x, object1y, object1w, object1h, object2x, object2y, object2w, object2h )
		return ( object1x + object1w >= object2x and
			     object1x <= object2x + object2w and
			     object1y + object1h >= object2y and
			     object1y <= object2y + object2h )
	end

	function circleCircle( object1x, object1y, object1r, object2x, object2y, object2r )
		return math.sqrt( ( object1x - object2x ) ^ 2 + ( object1y - object2y ) ^ 2 ) <= object1r + object2r
	end

	function asteroidCollision( asteroid )
		-- Since the asteroid is a square its radius is half the width (or height)
		-- This is also true of the ship, although its image is not offset
		return circleCircle( asteroid.x, asteroid.y, asteroid.radius, shipX + shipWidth / 2, shipY + shipHeight / 2.5, shipWidth / 5 )
			or circleCircle( asteroid.x, asteroid.y, asteroid.radius, shipX + shipWidth / 3, shipY + shipHeight / 1.4, shipWidth / 6.5 )
			or circleCircle( asteroid.x, asteroid.y, asteroid.radius, shipX + shipWidth / 3 + shipWidth / 2, shipY + shipHeight / 1.4, shipWidth / 6.5 )
	end

	-- "object" is any table with values for "x", "y", "width", and "height"
	function mouseAABB( mouseX, mouseY, object )
		return AABB( object.x, object.y, object.width, object.height, mouseX, mouseY, 0, 0 )
	end

	toDestroy = {}
	ID = 0

	function destroyAsteroids()
		for i = 1, #toDestroy do
			for j = 1, #asteroids do
				if toDestroy[i] == asteroids[j].id then
					table.remove( asteroids, j )
					break
				end
			end
		end
	end

	function createAsteroid( x, y, velocityX, velocityY, rotationSpeed, radius )
		ID = ID + 1
		local asteroid = {
			x = x,
			y = y,
			id = ID,
			rotation = 0,
			rotationSpeed = rotationSpeed,
			velocityX = velocityX,
			velocityY = velocityY,
			-- "or" allows a defualt value if `radius` isn't defined
			radius = radius or asteroidWidth / 2,
			update = function( self, dt )
				self.x = self.x + self.velocityX * dt
				self.y = self.y + self.velocityY * dt
				self.rotation = self.rotation + self.rotationSpeed * dt

				if self.y - self.radius > screenHeight then
					score = score + 50
					table.insert( toDestroy, self.id )
					table.insert( asteroids, randomAsteroid() )
					asteroidsPassed = asteroidsPassed + 1
					if asteroidsPassed % 5 == 0 then
						difficulty = difficulty + .1
					end
				end
				if self.velocityX < 0 and self.x + self.radius < 0 then
					self.x = self.x + screenWidth + self.radius * 2
				elseif self.velocityX > 0 and self.x - self.radius > screenWidth then
					self.x = self.x - screenWidth - self.radius * 2
				end

				if asteroidCollision( self ) then
					state = 'lose'
					if score > highScore then
						highScore = score
						love.filesystem.write( 'file.lua', 'return ' .. score )
					end
				end
			end,
		}
		-- Defined outside of the table so we can reference the radius
		asteroid.scale = asteroid.radius / ( asteroidWidth / 2 )

		-- Implicit `self` parameter with the colon syntax
		function asteroid:draw()
			love.graphics.draw( asteroidImage, self.x, self.y, self.rotation, self.scale, self.scale, asteroidWidth / 2, asteroidWidth / 2 )
		end

		return asteroid
	end

	function randomAsteroid()
		local vectorMagnitude = love.math.random( 100, 200 ) * difficulty
		local vectorAngle = ( 2 / 3 * math.pi - math.pi / 3 ) * love.math.random() + math.pi / 3
		local vectorX = vectorMagnitude * math.cos( vectorAngle )
		local vectorY = vectorMagnitude * math.sin( vectorAngle )

		local radius = love.math.random( asteroidWidth / 3, 2 / 3 * asteroidWidth ) * difficulty

		return createAsteroid( love.math.random( 0, screenWidth ), -asteroidHeight, vectorX, vectorY, love.math.random( -math.pi / 4, math.pi / 4 ), radius )
	end

	asteroids = {}
	for i = 1, 6 do
		table.insert( asteroids, randomAsteroid() )
	end

	function updateAsteroids( dt )
		for i = 1, #asteroids do
			asteroids[i]:update( dt )
		end
	end

	function drawAsteroids()
		for i = 1, #asteroids do
			asteroids[i]:draw()
		end
	end

	function createButton( text, x, y, width, height, callback )
		-- Vertical centering
		local _, lines = font:getWrap( text, width - 4 )
		local numLines = #lines
		local fontHeight = font:getHeight( 'A' )
		local textHeight = numLines * ( fontHeight + 2 ) - 2
		local textY = y + ( height - textHeight ) / 2

		local button = {
			text = text,
			x = x,
			y = y,
			width = width,
			height = height,
			callback = callback,
			color = { 255, 255, 255 },
			update = function( self, dt )
				local mouseX, mouseY = love.mouse.getPosition()
				if mouseAABB( mouseX, mouseY, self ) then
					self.color = { 125, 125, 125 }
				else
					self.color = { 255, 255, 255 }
				end
			end,
			draw = function( self )
				love.graphics.setColor( self.color )
				love.graphics.rectangle( 'fill', self.x, self.y, self.width, self.height )

				love.graphics.setColor( 0, 0, 0 )
				love.graphics.printf( text, self.x + 2, textY, self.width - 4, 'center' )
			end,
		}

		return button
	end

	replay = createButton( 'Replay?', 2, 2, 50, 50, love.load )
	quit = createButton( 'Quit?', 52, 52, 50, 50, love.event.quit )

	activeButtons = { replay, quit }

	function checkButtons( mouseX, mouseY )
		for i = 1, #activeButtons do
			local result = mouseAABB( mouseX, mouseY, activeButtons[i] )
			if result then return i end
		end
	end

	function updateShip( dt )
		local futureX = shipX + shipVelocityX * dt
		local futureY = shipY + shipVelocityY * dt
		
		if futureX < 0 then
			futureX = 0
		elseif futureX + shipWidth > screenWidth then
			futureX = screenWidth - shipWidth
		end

		shipX = futureX
		shipY = futureY
	end

	function updateShipVelocity()
		if ( love.keyboard.isDown( 'left' ) or love.keyboard.isDown( 'a' ) ) then
			shipVelocityX = -shipMoveSpeed
		end
		if ( love.keyboard.isDown( 'right' ) or love.keyboard.isDown( 'd' ) ) then
			shipVelocityX = shipMoveSpeed
		end
	end
end

function love.update( dt )
	states[state].update( dt )
end

function love.draw()
	states[state].draw()
end

function love.keypressed( key )
	states[state].keypressed( key )
end

function love.keyreleased( key )
	states[state].keyreleased( key )
end

function love.mousereleased( x, y, button )
	states[state].mousereleased( x, y, button )
end
`
